// Generated by CoffeeScript 1.6.2
(function() {
  var BindableDecor, decorable, type,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  type = require("type-component");

  decorable = require("./decor/decorable");

  BindableDecor = (function() {
    /*
    */
    function BindableDecor() {
      this.use = __bind(this.use, this);      this._available = [];
      this._id = 0;
      this.use(decorable);
    }

    /*
    */


    BindableDecor.prototype.use = function() {
      var decorator, decorators, options, _i, _len, _results;

      decorators = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _results = [];
      for (_i = 0, _len = decorators.length; _i < _len; _i++) {
        options = decorators[_i];
        if ((type(options) === "function") || options.options || options.getOptions) {
          options = {
            factory: options
          };
        }
        decorator = options.clazz || options["class"] || options.factory || options.decorator || options;
        if (!decorator.options) {
          decorator.options = decorator.getOptions;
        }
        _results.push(this._available.push({
          name: options.name || this._id++,
          decorator: decorator,
          inheritable: !!options.inheritable
        }));
      }
      return _results;
    };

    /*
    */


    BindableDecor.prototype.decorate = function(target, decor) {
      var decorators;

      if (decor) {
        decorators = this._findDecorators(decor);
      } else {
        decorators = target.__decorators;
      }
      if (decorators) {
        return this._setDecorators(target, decorators);
      } else {
        decor = this._findDecorators(target);
        target.constructor.prototype.__decorators = target.__decorators = decor;
        return this.decorate(target);
      }
    };

    /*
     Finds ALL the decorators for a bindable object, including the parent 
     decorators which should be inherited (but overridden by the child prototype)
    */


    BindableDecor.prototype._findDecorators = function(target) {
      var ct, decorators, pt, used;

      decorators = [];
      ct = target;
      pt = void 0;
      while (ct) {
        decorators = decorators.concat(this._findDecorators2(ct, pt).concat(this._findDecorators2(ct.constructor, pt != null ? pt.constructor : void 0)));
        pt = ct;
        ct = ct.__super__;
      }
      used = {};
      decorators.sort(function(a, b) {
        if (a.priority > b.priority) {
          return 1;
        } else {
          return -1;
        }
      }).filter(function(a) {
        if (!used[a.name]) {
          used[a.name] = true;
          return true;
        }
        return used[a.name] && a.inheritable;
      });
      return decorators;
    };

    /*
    */


    BindableDecor.prototype._findDecorators2 = function(proto, child) {
      var d, decorator, decorators, options, priority, _i, _len, _ref;

      decorators = [];
      _ref = this._available;
      for (priority = _i = 0, _len = _ref.length; _i < _len; priority = ++_i) {
        d = _ref[priority];
        decorator = d.decorator;
        if (options = decorator.options(proto)) {
          if (child && options === decorator.options(child)) {
            continue;
          }
          decorators.push({
            decorator: decorator,
            name: decorator.name,
            inheritable: decorator.inheritable,
            options: options,
            priority: priority
          });
        }
      }
      return decorators;
    };

    /*
    */


    BindableDecor.prototype._setDecorators = function(target, decorators) {
      var d, decor, _i, _len;

      for (_i = 0, _len = decorators.length; _i < _len; _i++) {
        decor = decorators[_i];
        d = decor.decorator.decorate(target, decor.options);
      }
      return void 0;
    };

    return BindableDecor;

  })();

  module.exports = function() {
    return new BindableDecor();
  };

}).call(this);
